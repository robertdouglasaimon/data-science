# -*- coding: utf-8 -*-
"""NumPy: análise numérica eficiente com Python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IZVXSSCwfva9lU-T8veeNr7eavvj5Kkl
"""

# AULA 1 -
import numpy as np # Importa a ferramenta NumPy

url = 'https://raw.githubusercontent.com/alura-cursos/numpy/dados/apples_ts.csv' # Atribui os dados externos a uma variável.

7*12+3 # 7 anos de informação vezes 12 meses do ano mais 3 primeiros meses de 2020 = 87.


# Explicando os parenteses do np.range:
# 1º coluna da tabela | Resultado da soma acima [87] +1 porque ele não vai até o ultimo valor, que é a quantidade de elementos da tabela. |
# Valor do incremento para que ele pule de 1 em 1 pela tabela.
np.arange(1, 88, 1) # Gera uma sequencia de valores.

dado = np.loadtxt(url, delimiter=',',usecols=np.arange(1, 88, 1))
dado

dado.ndim # Dados em 2 dimensões.

dado.size # Quantidade de elementos.

dado.shape # 6 linhas e 87 colunas.

dado_transposto = dado.T # Transforma linhas em colunas e colunas em linhas.



# AULA 2 -
datas = dado_transposto[:,0]

precos = dado_transposto[:,1:6]

import matplotlib.pyplot as plt # Importa a biblioteca Matplotlib.

datas = np.arange(1, 88, 1) # Gera uma sequencia de valores.

plt.plot(datas, precos[:,0]) # Plota o gráfico.
plt.title('Apple') # Título do gráfico.
plt.show() # Exibe o gráfico.

# Chamando cada coluna da tabela separadamente:
Moscow = precos[:,0]
Kaliningrad = precos[:,1]
Petersburg = precos[:,2]
Krasnodar = precos[:,3]
Ekaterinburg = precos[:,4]

# Testando se a separação das colunas deu certo usando Moscow:
Moscow

"""# Errata: Construção de arrays

No próximo vídeo o instrutor cometeu um equívoco. Para que o resultado contenha dados de um único ano, o intervalo começa no índice desejado e precisa ser encerrado no valor desejado + 1. Portanto, o primeiro intervalo começa no índice 0 (mês 1) e vai até o índice 12 (11+1, ou seja, fecha no mês 12). Seguindo essa lógica: o segundo intervalo começa no índice 12 (mês 13) e vai até o índice 24 (23+1, ou seja, fecha no mês 24); o terceiro intervalo começa no índice 24 (mês 25) e vai até o índice 36 (35+1, ou seja, fecha no mês 36); o quarto intervalo começa no índice 36 (mês 37) e vai até o índice 48 (47+1, ou seja, fecha no mês 48). Com isso, o código ficaria assim para os quatro anos:



```
Moscow_ano1 = Moscow[0:12]
Moscow_ano2 = Moscow[12:24]
Moscow_ano3 = Moscow[24:36]
Moscow_ano4 = Moscow[36:48]
```
O código disponível nas atividades do curso foi corrigido com base nessas informações.


"""

# Moscow e todos os outros que agora são colunas independentes se tornaram "Arrays Unidimensional"
Moscow.shape

# Usaremos Moscow para entender o porque daquelas flutuações de sobe e desce no gráfico separando os anos
# em gerando um gráfico dessas informações:

Moscow_ano1 = Moscow[0:12] # Primeiro ano de Moscow.
Moscow_ano2 = Moscow[12:24] # Segundo ano de Moscow.
Moscow_ano3 = Moscow[24:36] # Terceiro ano de Moscow.
Moscow_ano4 = Moscow[36:48] # Quarto ano de Moscow.

# Obs: Valores ajustados segundo a errata da alura xD

# Visualizando os dados selecionados:
plt.plot(np.arange(1,13,1), Moscow_ano1) # Primeiro ano de Moscow.
plt.plot(np.arange(1,13,1), Moscow_ano2) # Segundo ano de Moscow.
plt.plot(np.arange(1,13,1), Moscow_ano3) # Terceiro ano de Moscow.
plt.plot(np.arange(1,13,1), Moscow_ano4) # Quarto ano de Moscow.
plt.title('Moscow')
plt.legend(['Ano 1', 'Ano 2', 'Ano 3', 'Ano 4'], loc='upper right') # Legenda do gráfico e posicionamento da legenda no canto superior direito.
plt.show()

# - Comparando Arrays -

# Função array_equal: Verifica se dois arrays são iguais.
np.array_equal(Moscow_ano3, Moscow_ano4)

# Função allclose: Verifica se arrays são próximos(dentro de um intervalo).
np.allclose(Moscow_ano3, Moscow_ano4, 10) # 10 é o intervalo. Não houve uma diferença maior que 10 entre esses arrays,
                                          # não houve alguma inflação ou representativo que alterasse o valor das maçãs.

# Continuando a análise, vamos verificar o que há de errado com as demais cidades, partindo para a 2º cidade (Kaliningrad)..
plt.plot(datas, Kaliningrad)

# Chamando o array de Kaliningrad, notamos um erro. Existe um valor "NaN" no array, o que provavelmente está causando aquele
# "corte" no inicio do gráfico, devido a falta de valores  ou de valores incompletos ali.

# NaN: Not a Number (Valor não numérico)
Kaliningrad

# - Verificando a quantidade de valores NaN -

# Função isnan: Verifica valores não numéricos.
np.isnan(Kaliningrad)

# Agora usando a função "sum", nós vamos somar todos os itens do array e por fim  vamos saber quantos "NaN" tem dentro desse array,
# pois "sum" retorna também a quantidade de valores NaN, caso haja valores NaN nesse array.

# Função sum: Soma todos os itens do array.
np.sum(np.isnan(Kaliningrad))

# Calculando a média de forma manual:
(Kaliningrad[3]+Kaliningrad[5])/2

# Calculando a média usando a função "np.mean()":
np.mean([Kaliningrad[3], Kaliningrad[5]])

# Pegando o calculo da média e usando ele para SUBSTITUIR aquele valor NaN do gráfico para preencher a falha:
Kaliningrad[4] = np.mean([Kaliningrad[3], Kaliningrad[5]])

# Plotando novamente o gráfico para chegar se preencheu a falha:
plt.plot(datas, Kaliningrad)



# - Comparando as médias de preço de duas cidades -

# Chamando a média de Moscow:
np.mean(Moscow)

# Chamando a média de Kalinigrad:
np.mean(Kaliningrad)

