# -*- coding: utf-8 -*-
"""Pandas: conhecendo a biblioteca Pandas: conhecendo a biblioteca

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OOP4oSJ04ymxnHPKMpQewzNoJQYas7Px

# Conhecendo a base de dados (AULA 1)

Descrição

A base de dados que vamos utilizar para desenvolver o projeto é uma base com dados de diferentes tipos de imóveis do Rio de Janeiro, como apartamento, casas, comércios, dentre outros.

Nessa base, nós vamos encontrar os valores dos aluguéis de cada imóvel, condomínio, IPTU e também suas características, como: quantidade de quartos, suítes, vagas de garagem, etc.

Link para acessar a base de dados: aluguel.csv (https://raw.githubusercontent.com/alura-cursos/pandas-conhecendo-a-biblioteca/main/base-de-dados/aluguel.csv)

## Importando os dados
"""

import pandas as pd
import matplotlib.pyplot as plt

url ='https://raw.githubusercontent.com/alura-cursos/pandas-conhecendo-a-biblioteca/main/base-de-dados/aluguel.csv'
pd.read_csv(url)

pd.read_csv(url, sep=';') # "sep=';' = Separa por ; os itens da tabela.

dados = pd.read_csv(url, sep=';') # "sep=';' = Separa por ; os itens da tabela.
dados

dados.head(10) # Mostra as 10 primeiras linhas da tabela.

dados.tail(10) # Mostra as 10 últimas linhas da tabela.

type(dados) # Mostra o tipo da tabela.

"""## Características gerais da base de dados"""

dados.shape # Mostra a quantidade de linhas e colunas da tabela.

dados.columns # Mostra as colunas da tabela.

dados.info()

dados['Tipo'] # Mostra apenas a coluna Tipo, os dados dessa coluna são texto, logo, object pode também conter strings.

dados[['Quartos', 'Valor']] # Mostra apenas as colunas Quartos e Valor.
                            # Os dados dessas colunas são do tipo decimal e inteiro, logo, INT representa os números inteiros
                            # e FLOAT representa os números decimais.

"""# Análise exploratória de dados (AULA 2)

## Qual o valor médio de aluguel por tipo de imóvel?
"""

dados.head()

dados['Valor'].mean() # Mostra o valor médio de aluguel.

dados.groupby('Tipo').mean(numeric_only=True) # Mostra o valor médio de aluguel por tipo de imóvel.

dados.groupby('Tipo')['Valor'].mean() # Mostra o valor médio de aluguel por tipo de imóvel.

dados.groupby('Tipo')[['Valor']].mean().sort_values('Valor') # Mostra o valor médio de aluguel por tipo de imóvel.
                                                             # Transforma 'Valor' em um Data Frame.

df_preco_tipo = dados.groupby('Tipo')[['Valor']].mean().sort_values('Valor') # Mostra o valor médio de aluguel por tipo de imóvel e atribui ele a váriavel
                                                                             # df_preco_tipo.

df_preco_tipo.plot(kind='barh', figsize=(14, 10), color='purple') # Plota o gráfico do valor médio de aluguel por tipo de imóvel.

"""## Removendo os imóveis comerciais"""

dados.Tipo.unique() # Mostra os tipos de imóveis.

imoveis_comerciais = ['Conjunto Comercial/Sala',
                      'Prédio Inteiro', 'Loja/Salão',
                      'Galpão/Depósito/Armazém',
                      'Casa Comercial', 'Terreno Padrão',
                      'Loja Shopping/ Ct Comercial',
                      'Box/Garagem', 'Chácara',
                      'Loteamento/Condomínio', 'Sítio',
                      'Pousada/Chalé', 'Hotel', 'Indústria'] # Cria uma váriavel com os tipos de imóveis comerciais.

imoveis_comerciais

dados.query('@imoveis_comerciais in Tipo') # Cria uma tabela com os tipos de imóveis comerciais.

dados.query('@imoveis_comerciais not in Tipo') # Cria uma tabela com os tipos de imóveis não comerciais.

df_imoveis_residenciais = dados.query('@imoveis_comerciais not in Tipo') # Cria uma tabela com os tipos de imóveis não comerciais e atribui ele a váriavel.
df_imoveis_residenciais.head()

df_imoveis_residenciais.Tipo.unique()

df_preco_tipo = df_imoveis_residenciais.groupby('Tipo')[['Valor']].mean().sort_values('Valor') # Mostra o valor médio de aluguel por tipo de imóvel.
                                                                                             # Transforma 'Valor' em um Data Frame.
df_preco_tipo.plot(kind='barh', figsize=(14, 10), color='purple')
plt.title('Valor médio de aluguel por tipo de imóvel')
plt.xlabel('Valor')
plt.ylabel('Tipo')

"""## Qual o percentual de cada tipo de imóvel na nossa base de dados?"""

df_imoveis_residenciais.Tipo.unique()

df_imoveis_residenciais.Tipo.value_counts(normalize=True) # Mostra a quantidade de cada tipo de imóvel na nossa base de dados.
                                                          # normalize=True = Mostra o percentual de cada tipo de imóvel na nossa base de dados.

df_imoveis_residenciais.Tipo.value_counts(normalize=True).to_frame().sort_values('Tipo' , ascending=False)  # Mostra o percentual de cada tipo de imóvel na nossa base de dados.
                                                                                                            # .sort_values('Tipo' , ascending=False) = Transforma 'Tipo' em um Data Frame e ordena ele do menor para o maior.

df_percentual_tipo = df_imoveis_residenciais.Tipo.value_counts(normalize=True).to_frame().sort_values('Tipo' , ascending=False)

df_percentual_tipo.plot(kind='bar', figsize=(14, 10), color='green') # Plota o gráfico do percentual de cada tipo de imóvel na nossa base de dados.
plt.title('Percentual de cada tipo de imóvel na nossa base de dados')
plt.xlabel('Tipos')
plt.ylabel('Percentual')

"""### **Selecionando apenas os imóveis do tipo apartamento**"""

df_imoveis_residenciais.query('Tipo == "Apartamento"') # Mostra apenas os imóveis do tipo apartamento.

df_apartamentos = df_imoveis_residenciais.query('Tipo == "Apartamento"') # Mostra apenas os imóveis do tipo apartamento e atribui ele a váriavel.
                                                                         # df_apartamentos.
df_apartamentos.head()

"""# Tratando e filtrando os dados (AULA 3)

## Lidando com dados nulos
"""

# Metodo 'isnull'
df_apartamentos.isnull() # Mostra se há dados nulos na tabela.

df_apartamentos.isnull().sum() # Mostra a quantidade de dados nulos na tabela.

# Método "fillna"
df_apartamentos.fillna(0) # Preenche os dados nulos com 0.

df_apartamentos = df_apartamentos.fillna(0) # Preenche os dados nulos com 0 e atribui ele a váriavel.
df_apartamentos.head()

df_apartamentos.isnull().sum() # Mostra a quantidade de dados nulos na tabela.
                              # Aqui usamos isnull().sum() para conferir se os nulls foram completamente substituidos
                              # pelos 0. Para garantir que não há dados nulos no nosso dataframe de apartamentos o df_apartamentos.

# Método query
# Verificando se há valores zerados na coluna "Valor" para remover:
df_apartamentos.query('Valor == 0 | Condominio == 0') # Mostra apenas os imóveis que não possuem condomínio.

df_apartamentos.query('Valor == 0 | Condominio == 0').index # Mostra apenas os índices dos imóveis que não possuem condomínio.

registros_a_remover = df_apartamentos.query('Valor == 0 | Condominio == 0') .index # Mostra apenas os índices dos imóveis que
                                                                                   # estão com o valor zerado, ou que são Condominio mas que
                                                                                   # possuem o valor 0.

"""## Removendo registros"""

df_apartamentos.drop(registros_a_remover, axis=0, inplace=True) # Remove os registros que não possuem condomínio.

# Explicando o comando:
# registros_a_remover = Essa é a variável que está guardando todos index dos valores que estão zerados em "Valor".
# axis=0 = Se for 0 REMOVE apenas as LINHAS. E se for 1 REMOVE a coluna inteira.
# inplace=True = Garante que essa modificação seja PERMANENTE dentro do dataframe, logo, é vital que se tenha certeza do que está apagando.

df_apartamentos.query('Valor == 0 | Condominio == 0') # Usando essa query novamente só para checar se realmente foram apagados
                                                      # os registros que não tinham condomínio (E que tivessem como valor 0).

"""# Não existe mais nada na nossa base de dados que possa ser removido?

  Vamos verificar!
"""

df_apartamentos.head()

# Se analisaramos a coluna "Tipo", nós vemos que no momento, nesse DF só temos "Apartamento" nessa coluna,
# e essa coluna meio que perdeu o sentido, visto que todos os itens aqui são do mesmo tipo.
# Então vamos remove-la do df_apartamentos:


# Primeiro vamos usar o unique() para ter certeza que só há "Apartamento" no df:
df_apartamentos.Tipo.unique() # Mostra os tipos de imóveis.

# E agora com a certeza de que só há  "Apartamento" no df_apartamentos, vamos remover a coluna tipo:
df_apartamentos.drop('Tipo', axis=1, inplace=True) # Remove a coluna "Tipo".

df_apartamentos.head() # Checando com head() se a remoção foi bem sucedida.

"""## Filtros

### **1. Apartamentos que possuem `1 quarto` e `aluguel menor que 1200`**
"""

df_apartamentos['Quartos'] == 1 # Retorna uma series de valores boleanos. Onde as linhas que possuem TRUE possuem 1 e a FALSE um valor diferente de 1.

# E assim resolvemos a primeira problematica: Apartamentos que possuem 1 quarto.
selecao1 = df_apartamentos['Quartos'] == 1
df_apartamentos[selecao1] # Retorna apenas as linhas que possuem TRUE.

# E assim resolvemos a segunda problemática que é: Aluguel menor que 1200.
selecao2 = df_apartamentos['Valor'] < 1200 # Retorna uma series de valores boleanos. Onde as linhas que possuem TRUE possuem um valor menor que 1200 e a FALSE um valor diferente de 1200.
df_apartamentos[selecao2] # Retorna apenas as linhas que possuem TRUE.

# No entanto, ambos estão separados. Vamos juntar esses dois filtros e coloca-los na mesma tabela para fecharmos essa demanda:
selecao1 = df_apartamentos['Quartos'] == 1
selecao2 = df_apartamentos['Valor'] < 1200
selecao_final = (selecao1) & (selecao2)

df_apartamentos[selecao_final]

# Agora vamos salvar toda essa modificação em uma outra váriavel para facilitar para o time de machine learning na hora de
# vizualizar os dados:

df_1 = df_apartamentos[selecao_final]
df_1.head()

"""### **2. `Apartamentos` que possuem pelo menos `2 quartos`, `aluguel menor que 3000` e `area maior que 70`**"""

selecao = (df_apartamentos['Quartos'] >= 2) & (df_apartamentos['Valor'] < 3000) & (df_apartamentos['Area'] > 70) # Retorna uma series de valores boleanos.
df_apartamentos[selecao]                                                                                         # Onde as linhas que possuem TRUE possuem um valor menor que 3000
                                                                                                                 # e a FALSE um valor diferente de 3000.

# Armazenando o filtro em uma nova váriavel:
df_2 = df_apartamentos[selecao]
df_2.head()

"""## Salvando os dados"""

# Método to CSV

df_apartamentos.to_csv('dados_apartamentos.csv') # Salva o arquivo em um arquivo CSV.

pd.read_csv('dados_apartamentos.csv') # Lê o arquivo CSV.

# Explicando o "Unnamed: 0":
# Quando salvamos o arquivo no formato CSV, ele automaticamente gera novos indeces ordenados para
# cada uma das nossas linhas. E os indices antigos do nosso dataframe vão para uma outra coluna
# que o proprio sistema cria chamada "Unnamed: 0".

# Como não faz sentido para gente deixar essa coluna "Unnamed:0 " sem proposito ai, vamos remover ela da tabela.
# Para salvarmos o dataframe sem que essa coluna sem proposito apareça, colocamos um parametro na hora de salvar
# que impede a criação da mesma chamado "index=False". Ele impede que os index antigos de "Unnamed:0" fiquem
# poluindo a tabel, vamos fazê-lo agora:

df_apartamentos.to_csv('dados_apartamentos.csv', index=False) # Salva o arquivo em um arquivo CSV.

pd.read_csv('dados_apartamentos.csv') # Checando novamente com o read para ter certeza se foi salvo com a modificação.

df_apartamentos.to_csv('dados_apartamentos.csv', index=False, sep=';') # Salva o arquivo em um arquivo CSV.
                                                                       # sep=';' = Separa os itens da tabela por ';'

pd.read_csv('dados_apartamentos.csv', sep=';') # Checando novamente com o read para ter certeza se foi salvo com a modificação. E adicionando o sep para fazer a separação padrão.

"""# Manipulando os dados (AULA 4)

## Criando colunas numéricas
"""







"""## Criando colunas categóricas"""









